c11特性
	1.可以使用delete来显式禁止某些操作符(比如+ =的重载和new符号),还可以来禁止编译器生成析构函数,拷贝构造函数等函数
		{
		void *operator new(size_t) = delete;		//new符号禁用
		void *operator new[](size_t) = delete;		//new数组符号禁用
		
		X3& operator = (const X3 &) = delete;		//X3的=重载禁用
		X3(const X3&) = delete;						//X3的拷贝构造函数禁用
		}
	也可以用delete来避免一些期望转换例如
	{
		class X4
		{
		public:
			X4(double){}
			X4(int) = delete;
		};
		private:
			void int max(int a,int b);
			void int max(double a,double b)=delete;		//禁止max的double重载,同时禁止了向max函数传递double参数
	
	}
	如果程序员没有显式地为一个类定义某个特殊成员函数,而又需要用到该特殊成员函数时,则编译器会隐式的为这个类生成一个默认的特殊成员函数
	可以使用default,编译器将为显式声明的 default函数自动生成函数体,用default声明的函数比用户自己定义的默认构造函数获得更高的代码效率.
	default函数特性仅适用于类的特殊成员函数，且该特殊成员函数没有默认参数
	例:
	class X1
	{
	public:
		X() = default; //可以通过,该函数比用户自己定义的默认构造函数获得更高的代码效率
		int f() = default;      // err , 函数 f() 非类 X 的特殊成员函数
		X1(int, int) = default;  // err , 构造函数 X1(int, int) 非 X 的特殊成员函数
		X1(int = 1) = default;   // err , 默认构造函数 X1(int=1) 含有默认参数
	};
	
	
	2.nullptr　是 nullptr_t 类型的常量，而该类型定义了转到任意指针类型的转换操作符，同时不允许该类型的对象转换到非指针类型
	
	
	
	左值引用和右值引用
	左值和右值的分类标准:对他们取地址,如果能，就是左值；否则，就是右值。
	左值:一般放在赋值符号=的左边变量或对象(该对象或变量必须具有存储空间,而且用户可以区改变该对象或变量的内容)
	右值:只能对放在赋值符号=的右边常量或者表达式,该常量或表达式具有下面括号中的特性<------------------------------------------------
	左值引用是指对可以放在赋值符号=的左边或右边变量进行创建引用.(被引用的对象必须是有存储空间的变量或对象)                         |
	右值引用是指只能对放在赋值符号=的右边常量或者表达式进行创建引用,其最后结果一定要是一个进行创建引用.                            |
	(被引用的常量必须为一个常量(常变量不行(也不能是常变量的引用),必须是数值或者字符等已经决定好了的东西,这个东西必须是一开始就有,而且没有经过初始化))
	(被引用的表达式必须要最后能获得一个上述意义的常量)
	(右值引用不能绑定右值引用)
	(右值一般时一个亡值,一个临时的值,在下个语句执行时就会不存在的东西)
	例:创建右值引用
		int&& i=1;	
	例外:把右值绑定到左值引用上
		const int &i=1;
	移动:一般函数传入参数
	
	移动:
	在函数间创建同种对象时,可以使用原来不需要了的空间中的资源(分配的堆空间等),抛弃了以前创建同种对象需要拷贝的操作,可以提升部分程序性能.
	移动构造函数
	T(T&& t)
	通过传入一个右值,因为右值一般有将亡,临时的特性,可以对其随意修改,默认的构造函数中需要加const类型来防止某些不安全的操作和错误,但是右值一般不会存在该问题
	在移动构造函数通过某些操作来使新的对象直接使用t的一些空间来避免不必要的内存拷贝,提升了程序的性能,而且函数也会因为其是右值,而不会分配形参的空间,虽然左值引用也是这样.
	也可以自己编写一些函数来进行这种操作
	普通对象和普通变量的右边值转换		//被转换成右值后,就说明了你将在不使用他,而他的内存将被被的变量直接使用.这个和引用的意义不一样.
	std::move(对象名);
	static_cast<类型名&&>(变量名);
	注意在把变量转成右值后,最好不要使用和修改其内容,因为右值一般时被当作一个亡值,一个临时的值,在下个语句执行时就会不存在的东西.
	
	(函数的返回值算一种右值)
	例子:
	void f(std::thread t);					
	void g()
	{
		void some_function();
		f(std::thread(some_function));		//这里std::thread()返回一个右值作为f函数的参数
		std::thread t(some_function);
		f(std::move(t));					//这里调用std::move()函数,将t声明为一个右值,并且可能要之后在f中传递,修改t的值
	}