1.C++构造函数初始化列表优先与构造函数执行对于类中用const修饰的常量,可用初始化列表赋值,但构造函数无法对const对象赋值.
  可以用初始化列表初始化const类中常量,类中const常量只能被初始化列表初始化,或者在定义时就初始化.
	对于static变量和const变量还有const static变量的初始化例子
	class A{
	public:
		A():n5(8){}
		~A(){}

		static const int n3;
		static int n4;
		const int n5;				//可以写成const int n5=6;直接初始化
	private:
		int n1;
		int n2;
	};
	n3,n4的初始化必须在类外面,n5可以按上述方法初始化.
	const int A::n3=6;
	int A::n4=9;
  初始化列表也可以用来初始化指针变量，但是几乎一般都要配合构造函数的参数使用，例如
  class Student{
  private:
    char *m_name;
    int m_age;
    float m_score;
  public:
    Student(char *name, int age, float score);
    void show();
  };
  //采用初始化列表
  Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){}
  并且注意，初始化列表可以在写该函数实现时再写出来，不一定非要夹在类里面
  
  初始化列表可以使有派生类的类指定自己的基类
  例如:
  class A{
	public:
		A(int a):n1(8){
			n2=a
		}
		~A(){}
	private:
		int n1;
		int n2;
	};
	
	class B:public A{	//指定自己初始化的时候自己的基类以number为值初始化
	public:
		B(int number):A(number){}
		~B(){}
	};


2.c++函数可以有默认参数值,默认参数赋值必须全部写在参数列表右边,在调用函数时对应默认参数位置如果没有值传进来就默认
  使用默认参数值
 例子: void set(int a,int b,int c=100,int d=100){}
 
3.new完后不delete内存会使该内存一直存在直到程序运行结束(结束程序会返回占用的系统资源)

4.C++每个成员函数默认有一个this指针 例如 void crdd(P *this) (该类名为P)



5.const修饰的常成员函数中无法改变类中成员变量的值而且无法调用非const函数,常成员函数与同名而且同参数的成员函数互为重载。

  一般调用该名函数时 用const修饰对象调用的为const修饰的常成员函数 没用的就调用的那个没有const修饰的函数。
  
  1.const修饰的常成员函数相当于里面的this指针被const修饰，无法修改所指内存中内容
  
	const修饰成员函数时放在函数后面，修饰返回值时放在函数前面
  
  2.const修饰的对象,若为内容不能修改(例如const line Line=line(1,2))只能调用常成员函数，
  
	const修饰的对象,若为指针不能修改(例如Line line(1,2); Line* const p=&line;)则常成员函数和其他成员函数也可以调用
  
  对象的常引用就相当于该对象的常对象(内存空间还是原来的)
  
  
  
6.C++类中没有修饰词时，默认为private

7.C++默认继承为private(例如class a:b),而且默认变量和成员函数类型为private 

8.多个类继承一个类的时候最好使用虚继承，单个类继承就用普通继承

9.纯虚函数与访问限定符号(public private protected),//只要父类中有纯虚函数,继承的类就必须覆盖该函数.

10.含有纯虚函数的类被称为接口类,但是接口类不一定只有纯虚函数.

11.virtual和static不能同时修饰一个函数

12.纯虚函数的覆盖不能加static

13.子类可以调用父类的方法来调用接口类的父类中的函数.

14.虚继承可以防止在菱形继承时多次继承父类的函数和成员变量,即一个类被多次继承时,该类基类会被在子类中多次复制(c++和java的子类在构造时都会按层次向上构建其的长辈类),
	virtual可以在继承时写在访问权限前修饰，以表示虚继承
	棱形继承:
				类C<-类A->类B
				 |		   |
				 --->类D<---
	如果类C和类B不虚继承类A,然后再都被D继承,那么D构造时,会有两个类A的拷贝(非常浪费空间),这就是虚继承的用法
	注意:在这个关系中类C和类B都要虚继承类A,如果其中只有一个虚继承,那么类A还是会在类D中拷贝两份
	例:
		#include<iostream>
		class A{
			public:
					A()
					{
						std::cout<<"new A"<<std::endl;
					}
		};
		class B1:public A{
			public:
					B1()
					{
						std::cout<<"new B1"<<std::endl;
					}
		};
		class B2:public A{
			public:
					B2()
					{
						std::cout<<"new B2"<<std::endl;
					}        
		};
		class C:public B1,public B2{
			public:
					C()
					{
						std::cout<<"new C"<<std::endl;
					}     
		};
		int main()
		{
			C *c=new C();
			return 0;
		}
	此例中new C后将会有两个new A打印出来,若B1与B2 虚继承A 则将不会有这种现象,这个例子体现出了上面的原因
	
15.virtual保证了父类的指针指向子类对象时,调用子类和父类都有的函数时不会调用到父类函数(动态绑定)

16.虚函数被重写后,重写后在子类的函数依旧是虚函数(自动添加virtual),而且析构函数也是同样道理，c++中的类如果要被继承，就应该把析构函数设置为虚函数

	因为如果一个基类指针指向用 new 运算符动态生成的派生类对象，释放该对象时是通过释放该基类指针来完成的，这就可能导致程序不正确。
	
	例：
	class CShape  //基类
	{
	public:
		~CShape() { cout << "CShape::destrutor" << endl; }
	};
	class CRectangle : public CShape  //派生类
	{
	public:
		int w, h;  //宽度和高度
		~CRectangle() { cout << "CRectangle::destrutor" << endl; }
	};
	int main()
	{
		CShape* p = new CRectangle();
		delete p;							//此时调用的是CShape的析构函数,虽然声明的是CShape类对象,但是实际上还是CRectangle类,
											//这时调用CShape的析构函数,除非是有意而为,不然非常不符合逻辑
		return 0;	
	}
	
	如果上述例子中CShape类的析构函数声明为虚函数,则delete p时使用的是CRectangle的析构函数,这才符合逻辑

17.explicit关键字用来表明构造函数是显式方式显示的。explici关键字一般用来标识构造函数,让其必须为显式方式声明.
	例子:A类构造函数为A(int c);
		 在创建A类时可以A a=10;(自动使用了隐式转换,会自动执行构造函数把10给c 然后a变为一个A类对象)
		 若构造函数加上explicit,则会报错

18.C++可以调用C函数,但是在声明C程序中函数时候要加点东西

	#ifdef __cplusplus	//这句表示如果是C++程序调用就执行

	extern "C" {		//使用C语言编译规则(gcc)

    #endif				//结束if

 
	#ifdef __cplusplus	//同上

    }

    #endif				//结束if
	
19.C可以调用C++的程序,但是要对C++类进行包装,然后弄成函数给C程序调用

20.operator 运算符重载符号

21.c++在声明成员函数为static之后,在其他文件或本文件中写该函数时的实现时，不用再添加static 不然会报错

22.类中static成员变量必须在外面初始化

23.使用初始化列表时,列表中的变量全未赋值,数值无法确定,
	此时如果用一个列表项的值初始化另外一个列表项,那么该列表项的值是不确定的
例:
	class A
{
public:
    A():n2(0),n1(n2 + 2){}
    ~A(){}

    void print()
    {
        cout << "n1:" << n1 << " ,  n2:" << n2 << endl;			//n1的值是n2未初始化前的值+2
    }

private:
    int n1;
    int n2;
};
初始化A后运行后会发现n1为n2未初始化时的值+2,未初始化时变量的值可能为任意值

24.c++类初始化时只会把全局对象的成员变量初始化值为0,对于其他变量初始化为未知(这个情况只针对于没有用new初始化的对象)
上述例子把类A对象的初始化放在所有函数外面会发现n1=0+2,因为此时类A对象声明为全局,n1和n2一开始都为0

25.c++销毁对象和变量时(自动在栈中销毁),会按定义的顺序从尾到头销毁对象和变量(栈的后进先出)

26.c++和Java不同 你在哪创建他的对象和成员变量就都在那(在栈区创建就都在栈区,在堆区创建就都在堆区)

27.c++函数就算抛出异常,他依旧会在抛出异常后销毁局部变量.

28.每个类的成员函数都有一个默认的参数,即一个指向该类对象的指针,参数名为this

29.c++的函数引用传参就相当于把真正的变量传了进来,之后对该变量修改,其中的值也会改变,而不是像原来那样只是在内部声明两个局部变量,然后把值传过来
	引用为一个变量的别名,其地址和原变量地址一样.
	注意,引用的定义为int flag(A& a);
		  而指针的定义为int flag(A *a);
	两者在函数中是不一样的
	
30.引用参数传递过程中,被调函数的形式参数也作为局部变量在栈中开辟了内存空间,但是这时存放的是由主调函数放进来的实参变量的地址
	被调函数对形参(本体)的任何操作都被处理成间接寻址,即通过栈中存放的地址访问主调函数中的实参变量(根据别名找到主调函数中的本体).
	因此,被调函数对形参的任何操作都会影响主调函数中的实参变量.
	
	引用传递和指针传递是不同的,虽然他们都是在被调函数栈空间上的一个局部变量,
	但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量.
	而对于指针传递的参数,如果改变被调函数中的指针地址,它将应用不到主调函数的相关变量.
	如果想通过指针参数传递来改变主调函数中的相关变量(地址),那就得使用指向指针的指针或者指针引用.

31.C++在写了构造函数后不会再默认有一个默认构造函数.

32.C++同时提供了4种新的强制类型转换形式(通常称为新风格的或C++风格的强制转型)
	:const_cast(expression)、dynamic_cast(expression)、 reinterpret_cast(expression)和 static_cast(expression,该转换编译时类型检查)，每一种都适用于特定的目的，具体如下：

	1.dynamic_cast主要用于执行"安全的向下转型(safe downcasting,该转换运行时检查类型)",也就是说,要确定一个对象是否是一个继承体系中的一个特定类型.
	支持父类指针到子类指针的转换,这种转换是最安全的转换.它是唯一不能用旧风格语法执行的强制类型转换,也是唯一可能有重大运行时代价的强制转换。
	
	dynamic_cast主要用于类层次结构中父类和子类之间指针和引用的转换,由于具有运行时类型检查,因此可以保证下行转换的安全性,
	何为安全性?即转换成功就返回转换后的正确类型指针,如果转换失败,则返回NULL,之所以说static_cast在下行转换时不安全,是因为即使转换失败,它也不返回NULL.
	
	在上行转换中,static_cast和dynamic_cast效果是一样的,而且都比较安全,因为向上转换的对象一般是指向子类对象的子类类型指针;
	而在下行转换中,由于可以定义就不同了指向子类对象的父类类型指针,同时static_cast只在编译时进行类型检查,而dynamic_cast是运行时类型检查,则需要视情况而定.
	在向下转型中(父类转成子类)dynamic_cast转型后会在运行时检查目标是否会使用自己没有的函数,static_cast不会


	2.static_cast 可以被用于强制隐形转换（例如，non-const对象转换为const对象，int转型为double，等等），它还可以用于很多这样的转换的反向转换 （例如，void*指针转型为有类型指针，基类指针转型为派生类指针），
	但是它不能将一个const对象转型为non-const对象(只有 const_cast能做到),应用到类的指针上,意思是说它允许子类类型的指针转换为父类类型的指针(这是一个有效的隐式转换),同时,也能够执行相反动作:转换父类为它的子类.
	
	(1)用于基本数据类型之间的转换，如把int转换为char，把int转换成enum，
	但这种转换的安全性需要开发者自己保证(这可以理解为保证数据的精度,即程序员能不能保证自己想要的程序安全),
	如在把int转换为char时,如果char没有足够的比特位来存放int的值（int>127或int<-127时）,那么static_cast所做的只是简单的截断,及简单地把int的低8位复制到char的8位中,并直接抛弃高位。

	(2)把空指针转换成目标类型的空指针

	(3)把任何类型的表达式类型转换成void类型

	(4)用于类层次结构中父类和子类之间指针和引用的转换.

	对于static_cast，上行转换时安全的,而下行转换时不安全的,因为static_cast的转换是粗暴的,
	它仅根据类型转换语句中提供的信息(尖括号中的类型)来进行转换,这种转换方式对于上行转换,
	由于子类总是包含父类的所有数据成员和函数成员,因此从子类转换到父类的指针对象可以没有任何顾虑的访问其(指父类)的成员。

	3.const_cast一般用于强制消除对象的常量性.它是唯一能做到这一点的C++风格的强制转型.这个转换能剥离一个对象的const属性,也就是说允许你对常量进行修改.const_cast<int*>(const_p);

	4.reinterpret_cast 是特意用于底层的强制转型(了解就好)
	
	使用方法
	static_cast<目标类型>(要转换类型的变量)
	其他两个相同,但是const_cast只能在非const和const间转换


32.可以参考第73条
	拷贝构造函数参数必须是const T& t的原因(设T为某种类,可以根据需求不加const但是一定要加&)
	要用&的原因:会无限递归创建下去,假设为参数为(const T t)不加&时是值传递,(假设传入变量为a),那么以a为对象,执行A b = a;时,会调用b的拷贝构造函数,此时实参a会被赋值给形参other,
				相当于语句A other = a;又会继续调用other的拷贝构造函数,将a赋值给对象other的拷贝构造函数的形参othern,如此一来,就会形成一个递归操作而且没有结束条件.
				而传入别名就不会让形参调用构造而循环的调用构造.
		
	要加const的原因:	1.因为const的特性,可以保证某些数据的安全
						2.当函数返回一个对象时，编译器会生成一个临时对象返回,但是这个临时对象具有const的特性。
						
						  函数以对象作为返回值时会调用拷贝函数(传给调用该函数的函数时(假设该函数为函数A,调用函数A的函数为函数B),
						  函数B会使用该临时对象创建一个新的对象,而因为临时对象有const特性,而其拷贝函数无const属性(有 没有被const修饰的 引用类型的 形参 的函数,其不能在对应位置传入被const修饰的参数)
	 
	自动用拷贝构造函数有三种情况：
	1、拿对象初始化对象

	2、拿对象作为函数的参数		因为形参要被创建出来，这个构造函数不加const也没关系

	3、拿对象作为返回值			函数返回时,会拷贝对象或变量到一个临时变量(如果返回不为引用)，
								这种例子是直接
								TestInformation test(TestInformation T)
								{
									return TestInformation();			//无数据载体变量，直接新建一个对象并返回对象，就会建立一个临时变量把数据传出去
								}
								而像这种有载体的数据例如
										TestInformation test(TestInformation T)
										{
											TestInformation B=T;		//B作为数据载体对象,返回时也会建立临时变量,因为出了函数后,局部对象全部被销毁了,需要一个变量传递数据
											return B;
										}
	对于是否有时候拷贝构造函数不加const,一般99.9%的情况都是建议加
	
	程序中有以下几种情况时 拷贝构造函数不用加const:
	
	1.程序中完全无以该类为返回值的函数
	
	2.程序中完全无以该类引用的const形式为形参的函数



33.c++ The Rule of Three规则:
							如果你需要自己显式地声明一个类的析构函数，那么你可能也需要同时显式地声明它的拷贝构造函数以及拷贝赋值函数(重载=),而不能用default来默认该函数;

34.当使用显示调用构造函数的方式对类进行初始化,类中的所有变量就会被初始化为0;
	例子:	A a=A();	//类中包括指针全部被初始化为0了,在堆中也是一样	这个属于栈创建,最后会自动销毁
			A a;		//意义不明,其中值没有初始化,只是定义了一个A类对象a;
	基本类型也可以使用这个初始化为0值或者NULL

35.c/c++宏中,
	#的功能是将后面一个宏参数转移为相应变量,即对其后面的宏参数进行字符串化操作(Stringfication),简单说就是在对它所引用的宏变量通过替换后在其左右各加上一个双引号.
	##的功能是将后面一个宏参数转移为相应变量.		
			
36.C++模版的优点和缺点
	优点:
	1.灵活性, 可重用性和可扩展性;

	2.可以大大减少开发时间，模板可以把用同一个算法去适用于不同类型数据，在编译时确定具体的数据类型;

	3.模版模拟多态要比C++类继承实现多态效率要高, 无虚函数, 无继承;

	缺点:
	1.易读性比较不好，调试比较困难;

	2.模板的数据类型只能在编译时才能被确定;

	3.所有用基于模板算法的实现必须包含在整个设计的.h头文件中, 当工程比较大的时候, 编译时间较长;
	
37.注意c/c++在函数中创造对象或者变量指针时,就算最后函数调用完毕,也是指清空了他们指针的值,他们指向地址的值没有清空.函数调用完后只清理局部变量的值,
	而且函数的清理也只是把变量的相关性给清除了,变量对应空间中的值依然存在.
	c++的delete关键字可以清空指针变量指向的值
	例:
		using namespace std;
		int *pp()
		{
			int* p;
			int pp;
			pp=1;
			p=&pp;
			cout<<*p<<endl;

			return p;
		}
		int main()
		{
			int *p;
			p=1();
			cout<<*p<<endl;
		}
	最后会输出两个1,这说明了指针指向的值并没有被消除
	但是这样使用非常危险,这个时候,&PP这个地址被称为野地址,胡乱使用可能会发生指针相关错误
	

38.友元函数不能被子类继承


40.c++的结构体使用可以和类一样(也有移动 拷贝 构造 析构函数),
	结构体中变量默认为public,默认的成员函数也为public,结构体之间的继承默认为public.
	
	
41.c++的三种继承方式
					基类public成员   基类protected成员   基类private成员
					
	public继承			public			 protected			 子类中不可见
	
	protected继承		protected		 protected			 子类中不可见
	
	private继承			private			 private			 子类中不可见
	
	
43.c++中类中protected类型在被使用时(除继承外的使用),相当于private


44.c/c++进程间如果没有使用通信手段,将不能进行数据读取和共享
	例如获得一个进程里面变量的地址后,虽然可以再另外一个进程里面给指针赋值该地址,但是无法修改数据和读取该数据
	
	
45.每个类都有一个默认的=重载,也相当于拷贝函数
	T& operator=(const T&)
	该等号重载为浅拷贝,只是返回了一个引用
	
46.动态区域,用{}括起来的代码区,里面的对象或变量的生命周期只在{}中生效
 例子:
		{
			int i=9999;
		
		}
		std::cout<<i<<std::endl;			//报错 i没有定义

47.c/c++中用read和write读取/写入数据时,每次读取/写入1024个数据的效率比较高,而且该值最好为2的次方数,该数在16以下时将大幅度降低效率(也不是越高效率越好)

48.c/c++在内存泄漏后,进程结束时,泄露的内存会由系统回收(很老的系统不会)

49.sizeof在编译过程中就已经计算了长度,而且在字符串中将包括最后一个null的长度,但是strlen不会,strlen会经过一次函数调用

50.模板在被编译的时候会经理两个阶段,第一次不会做类型检查,第二次才会结合进行调用,
   使用模板的很多问题会发生在第一阶段检查,模板类型调用的函数或变量不能依赖于该类型
   就相当于第一次替换,第二次检查
   
51.使用模板函数时如果没有说明模板类型,编译器将会进行自动推断.将自动把模板类型定义为你传入的的变量类型
	这个被称为隐式推断,但是这个不一定能解决所有类型转换

52.c++不允许定义引用的指针,但是可以定义指针的引用

53.函数返回时会把变量或对象赋值给一个临时的对象或变量,返回引用可以解决这个问题
	但是注意,这并不表示你可以把函数在栈中的变量直接拿出来给别的变量.

54.类模板中初始化静态变量的时候仍然要在外面添加模板类型
	例子
	template<typename T>
	class A{
		public:
				static T value;
	}
	template<typename T>
	T A<T>::value=0;
	
	
55.类模板可以嵌套递归初始化
	template<typename T>
	class Arry{
		private:
				T a[3];
	}
	可以这样初始化
	Arry<Arry<int>>  d;					//二维数组d,同理可以嵌套到N维数组
	Arry<int>表示一维数组
	Arry<Arry<int>>	表示一个类型为Arry<int>的一维的Arry,所以即为二维数组
	如果重载了[]可以进行多维输出
	
56.类模板的特化版本
	template<typename T1,typename T2> class A{}				//普通
	template<> class A<char const*,int>{}		//全部特化
	template<> class A<int,short>{}				//全部特化
	template<> class A<56,58>{}					//全部特化
	template<> class A<T,short>{}				//局部特化
	template<> class A<T,5+6>{}					//局部特化
	相当于类模板的重载
	
	传入模板类型时模板的参数也可以是常量,也可以是类型,可以是常变量,但不能是变量
	(不能传入变量的原因,因为模板是在编译阶段替换和检查,而变量是运行阶段才分配内存和使用)
	传入常量时要模板支持传入常量,例如
	template<typename T,int t>
	class A{
	public:
			static int a;
			int b;
			A()=default;
			~A()=default;
	public:
		int d[t];
	};
	可声明
	A<int,10> a;
	A<int,1+5> b;
	A<T,5+aa> c //aa为变量
	不可以

57.typename可以解决嵌套依赖
	你如果在一个模板类里面定义了一个类型(typedef一个类型或者定义了一个类,这个类型称为该模板的嵌套从属名称),
	(从属名称就是尖括号里面的那些T什么的)
	那么在其他模板中使用的时候,直接使用该模板中的类型可能会发生歧义
	(可能有时使用这些东西取决于模板中从属名称的类型)
	这个时候要在使用时前面加上typename,告诉编译器不要想太多
	这个时候要在前面加上typename
	例:
		class A{
		public:
			A()=default;
			~A()=default;
			
			typedef inttt int;
			
			class C{
			};
		};
		template<typename T>
		void gogogo(){
		   typename T::C c;				//不加typename就会报错
		   typename T::inttt b;			//不加typename就会报错,因为编译器认为产生歧义了,
										//以为是T是个存在的类,而不是从属名称
		}
		

58.template的另外个作用
	模板函数可以写在类里面(template也在类里面)
	也可以有类中模板类
	但是这个时候要在调用该模板函数或者类中模板类时用template解决依赖于模板参数的嵌套模板,即在函数前面加template
	例:
	class A{
		public:
			template<typename T>
			void foo(){
				T t;
			}
	}
	A a;
	a.template foo<int>();		//写成a.foo<int>();会报错
	
59.类模板中的参数可以是一个类模板
	template<typename A,template<typename CC,typename DD> B>
	class nb{}
	typename声明的参数必须是具体类型或者类类型
	
60.int i=int();	//i被赋值为0,double,float应该也类似,其他基本类型这样初始化都是默认值,
	比如String			""
		char			''
		int/long		0
		bool			false
		指针类型		NULL
		
61.虚函数和模板
	虚函数覆盖条件必须是模板参数也一致
	例子
	template<typename T>
	class A{
		virtual void foo(T const &t){
			std::cout<<"A"<<endl;
		}
	
	}
	
	template<typename T>
	class B:public A{
		virtual void foo(T const &t){
			std::cout<<"B"<<endl;
		}
	
	}
	A<int> *a=new B<int>();
		a->foo();		//覆盖有效
	A<int> *a2=new B<double>();
		a2->foo();		//覆盖无效,关系为隐藏
		
	可以进行这样的继承
	template<typename T>
	class B:public A<int>
	
	template<typename T,typename Y>
	class B:public A<Y>
		
62.虚拟函数不能是模板函数

63.模板分离编译的时候
	g++的-c选项对模板只会进行一次编译,编译后的.o文件中的模板信息为空,
	由于c++编译器的特性(一个文件只编译一次),就算编译.cpp文件也不会生成含有模板的.o文件
	就算.h的定义文件和.cpp的实现文件一起编译,直接链接(不加-c),还是会报错
	解决方法(三个方法都巨麻烦):
			  1.声明和实现全写在.h文件里面				//方法名div			
			  2.声明的.h文件中实现的.cpp文件的包含放在.h文件尾部(做了一次编译,也做了二次编译)	//方法名inc
			  3.在实现的,cpp文件末尾提前把要使用的模板声明,
				记得声明前面都要加template,函数和类都要声明
				至于类中的模板函数则要额外声明//方法名ins
				
64.g++可以用-c选项直接编译头文件,会生成.h.gch文件,
	下次编译含有编译前头文件的文件时,编译速度会大大降低
	例子
		//hello.h
		#include<iostream>
		using namespace std;
	
		g++ -c hello.h			//将会生成hello.h.gch(不需要-o,改名后失效,必须第一个·前的名字和你的头文件一样,后缀不能变)
		
		优点,在不修改头文件使用时可以大大降低编译速度
		缺点,修改头文件后又要重新编译
		
65.所有类型的指针都可以赋予给void类型的指针变量,反过来则需要转换.所有没有写类型的函数都默认为int,而不是void
		
66.函数模板
	template<typename T>
	void foo(T&& t)
	{}
	t为右值的时候,T&&会被推导为一个右值类型
	t为左值得时候,T&&会被推导为一个左值引用
	即你输入左值或者右值都可以
	int i = 42;
	foo(i); // foo<int&>(i)		//差不多就是&&可以视为是原始的引用类型,而int& &&可以类似于int&
	foo(42); // foo<int>(42)
	不过对于模板,你最好加上类型

67.数组里面buf[0]=*(buf+0)
		   0[buf]=*(0+buf)

68.C++里面一般&和变量在一起是取地址,和类一起时是引用

69.c++构造函数有很多种，只要你在建立类时能正确的使用你建立的其中一种构造函数就可以。
	例：
	class TestInformation
	{
	public:
		int a;
		int b;
	public:
		TestInformation():a(1),b(2){}
		~TestInformation(){};
		TestInformation(const TestInformation &son){};
		TestInformation(TestInformation *son){
			this->a=son->a;
			this->b=son->b;
		};
		TestInformation(int value1,int value2)
		{
			this->a=value1;
			this->b=value2;
		}
		//还有移动构造函数，构造函数们都构成重载，构造函数都默认返回你要建立的对象，但是你无法规定返回值
	};

70.注意c/c++在用函数参数传递数据而不是用返回值传递数据时,要注意传入时是指针还是变量地址。
	例:
		#include<iostream>
		void p(int *a,int *b);
		int main()
		{
			int *a;
			int *b;
			p(a,b);
			std::cout<<a<<b<<std::endl;
			return 0;
		}
		void p(int *a,int *b)
		{   
			*a=1;
			*b=2;

		}
		上述中只是把函数中局部变量的地址值给了指针形参,而在main中,a和b的值仍不变
	
71.c中可以用void*的指针将一个类型的指针赋予给另外一个类型的指针而不用显示说明,但C++中必须显示说明
	例:
	#include<stdio.h>
	int main()
	{
	   void *b;
	   int *i;
	   char *c;
	   char a[4]="abc";
	   int t=5;
	   i=&t;
	   c=a;
	   b=t;
	   c=b;
	}
	在C++中会出错,C中只会出现警告
	C++中每次指针间类型转换都要显示说明,否则会出错。而C中可以任意转换,只会警告。

72.c++可以有成员函数指针,不管是静态还是非静态
	无论如何定义成员函数指针(静态还是非静态),都是类名::函数名,但是静态函数指针的调用不需要对象,而非静态需要
	说实在的非静态成员函数指针的使用像换了个别名,不是很实用.
	
	例子:
	#include <stdio.h>
	#include <iostream>
	class MyClass {
		public:
			static int FunA(int a, int b) {
				cout << "call FunA" << endl;
				return a + b;
			}
		  
			void FunB() {
				cout << "call FunB" << endl;
			}
		  
			void FunC() {
				cout << "call FunC" << endl;
			}
		  
			int pFun1(int (*p)(int, int), int a, int b) {
				return (*p)(a, b);
			}
		  
			void pFun2(void (MyClass::*nonstatic)()) {
				(this->*nonstatic)();
			}
	};
	int main() {
		MyClass* obj = new MyClass;
		// 静态函数指针的使用
		int (*pFunA)(int, int) = &MyClass::FunA;
		cout << pFunA(1, 2) << endl;
		 
		// 成员函数指针的使用
		void (MyClass::*pFunB)() = &MyClass::FunB;
		(obj->*pFunB)();
		 
		// 通过 pFun1 只能调用静态方法
		obj->pFun1(&MyClass::FunA, 1, 2);
		 
		// 通过 pFun2 就是调用成员方法
		obj->pFun2(&MyClass::FunB);
		obj->pFun2(&MyClass::FunC);
	 
		delete obj;
		return 0;
	}

73.c++当引用作为函数参数时,若该引用参数未用const声明,那么将不可以传入右值给该引用
	例子:
		#include <iostream>
	using namespace std;
	class A
	{
	public:
		A():n2(0),n1(n2 + 2){}
		A(int &a){														//		2处
			this->n1=a;
			this->n2=a;
		}
		~A(){
		   
		}

		void print()
		{
			cout << "n1:" << n1 << " ,  n2:" << n2 << endl;			//n1的值是n2未初始化前的值+2
		}

	private:
		int n1;
		int n2;
	};
	A a;
	int main()
	{
	   //int p=6;
	   //a.print();
	   A b=A(6);														//		1处
	}
	该例子中,1处会报错,若要使其正确,必须在2处加上const
	
	原因:
	
	数据传入形式参数前,若传入一个右值,则会现有一个临时变量存放,但是一般这个临时变量程序员无法操作,而且操作了也无意义,
	所以若要传入右值,则使用const typename &valuename
	数据传入形式参数前,若传入一个变量,则一般编译器会认为该变量会在函数中修改(修改对应引用后也会修改对应变量),故一般加上const来防止以外的修改
	
	关于对象引用作为参数的情况:
	过于复杂,建议在函数中对象引用参数前都加上const修饰(包括类拷贝函数),一般也为了防止被拷贝的类被修改,都会加
	
74.c++继承时,在成员变量方面,子类继承父类的变量但是该变量是父类的(详情参考c++继承后类的构建),子类只可以用对应权限访问与修改
	对于继承下来的变量,在子类中显示使用为 
	子类->父类::父类变量
	
	若这样使用
	
	子类->父类变量
	
	变量的所有权将追溯到上一个拥有该同名变量的父类
	
	例:
	class A
	{
		public:
			A()
			{
				this->b=1;
				this->a=2;
			}
		public:
			int at;
			int bt;
	};
	class B:public A
	{
		public:
			int at;
			int bt;
	};
	class C:public B
	{

	};
	若	C *c=new C();
	直接使用c->at使用的是子类C的父类B中的变量at
	若声明	c->A::at	使用的是子类C的祖辈类A中的变量at

75.c++纯虚函数必须重写,但是虚函数不一定要重修,
	在接口类中可以定义若干空的纯虚函数来表示让继承的类有选择他们觉得有兴趣的虚函数(方法)来重写
	例:
		class interface
		{
			public:
				virtual void OpenDoor(){}
				virtual void OpenNiceDoor(){}
				virtual viod OpenGoodDoor(){}
				
				virtual void SelectSQL()=0;
		};
		
76.C++重写和重载后 函数访问类型可以不一样,
	重载必须函数名相同,参数列表不同,	但是返回值类型不同但参数列表相同的重载不支持。
	重写必须返回值类型是要重写函数的返回值类型相关的类(继承下来的或是其祖辈类),参数列表必须相同。

77.g++和gcc编译时-L只是会让你指定库去解析程序中未定义符号,
	但是运行时,不一定会去-L指定目录中寻找库,要看gcc默认程序运行时寻找库路径
	例:
		程序运行时会去/usr/lib64等目录寻找库文件,
		此时库文件不在这些目录里,	文件在/usr/local/lib64 叫libevent.so
		编译时裸编译会报错,未定义符号	g++/gcc main.cpp/main.c -o main.out
		指定动态库路径,编译成功			g++/gcc main.cpp/main.c -o main.out -levent -L/usr/local/lib64
		运行							main.out
										报错,没有找到库文件libevent.so
		复制libevent.so到/usr/local/lib64,程序可以运行
		
78.函数的重载与默认参数一起使用容易遇到二义性,请注意.
	例:
	 class A
	{
		public:	
		  void func(int a, int b, int c = 0) {}
		  void func(int a, int b) {}
	};
	int main()
	{
		A a;
		a.func(1, 2); // 二义性出现
     return 0;
	}

79.注意,纯虚类(抽象类)不可做为函数的返回类型,但是其指针可以.
	例:
		class ProtoType
		{
			public:
				virtual ProtoType clone()=0;		//抽象类作为返回类型,直接报错
		};
		
		class ProtoType
		{
			public:
				virtual *ProtoType clone()=0;		//抽象类指针作为返回类型,允许操作
		};
		
80.请注意,每个类你如果不想写原本的构造函数,而写了个其他的构造函数,
	这时候你也得有个空构造函数,不然隐式建造类(直接栈上创建,像定义变量那种)的时候会容易无法匹配到对应的构造函数
	例:
	class aComplexClass
	{
    public:
        //aComplexClass(){}
        aComplexClass(aComplexClass* a){
            this->A=a->A;
        }
    private:
        int A;
	};
	int main()
	{
		aComplexClass A;			//直接报错,没有默认构造函数
	}

81.就算成员函数的访问类型是private和public的,在相同类 类型的对象中也是可以互相访问的
	例:
		class aComplexClass:public ProtoType
{
    public:
        aComplexClass(){}
        aComplexClass(aComplexClass* a){
            this->A=a->A;						//虽然对象*a的A是私有的,但是同类 类型的对象*this依旧可以访问
        }
    private:
        int A;
};

82.c++ 类的前向声明的用法
	该方法声明的类
	只能用于定义指针、引用、以及用于函数形参的指针和引用,也可以是友元函数.
	不能定义对象(因为此时编译器只知道这是个类，还不知道这个类的大小有多大),
	也不能访问类的对象，任何形式的访问都不允许(因为此时根本不知道有些什么成员).
	类的向前声明就是类定义前用class 类名	在前声明。
	例:
		class B;		//类的前向声明
		class A
		{
			public:
				B b;
		}
		class B			//在这之前类B属于不完整,不知晓其有什么函数和变量
		{	
			
		}
	如果想要两个类可以互相的调用其方法和变量,看下面一条(不过类最好是单向需要,而不是双向需求)

83.互相的.cpp文件互相包含.h文件就完事,但是别忘记#ifndef #define #endif
	虽然代码感觉会很混乱,但是很有用

84.c++存储类

85.linux下查看可执行程序执行时寻找所求依赖库过程
	命令

	LD_DEBUG=libs /PATH/PROGRAMNAME -v

	其中：
	PATH 为程序目录
	PROGRAMNAME 为程序名称
	
	输出log保存可以使用
	
	LD_DEBUG=all LD_DEBUG_OUTPUT=log  ./main  
	
	会生成一个output指定文件名加进程号结尾的文件
	例如：log.4476